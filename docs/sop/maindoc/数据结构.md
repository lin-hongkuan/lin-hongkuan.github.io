---
title: 数据结构
date: 2026-02-14 00:00:00
description: 数据结构复习笔记
tag:
  - 数据结构
  - 算法

top: 0
sticky: 0
---

# 数据结构

<!-- ## 目录 (Table of Contents)

- [绪论 — 基础与要点](#绪论--基础与要点-)
  - [嵌套复杂度分析](#嵌套复杂度分析)
- [线性表](#线性表)
  - [顺序表](#顺序表)
  - [链表](#链表)
  - [顺序表与链表的比较](#顺序表与链表的比较)
- [栈与队列](#栈与队列)
  - [栈](#栈)
    - [栈的顺序存储结构](#栈的顺序存储结构)
    - [栈的链式存储结构](#栈的链式存储结构)
  - [队列](#队列)
    - [队列的顺序存储结构](#队列的顺序存储结构)
    - [队列的链式存储结构](#队列的链式存储结构)
  - [双端队列](#双端队列)
  - [栈和队列的应用](#栈和队列的应用)
- [数组与特殊矩阵](#数组与特殊矩阵)
  - [数组](#数组)
  - [数组的存储结构](#数组的存储结构)
  - [特殊矩阵的特殊压缩](#特殊矩阵的特殊压缩)
- [串](#串)
  - [串的定义和实现](#串的定义和实现)
  - [串的存储结构](#串的存储结构)
  - [串的模式匹配](#串的模式匹配)
- [树与二叉树](#树与二叉树)
  - [树的基本概念](#树的基本概念)
  - [树的性质](#树的性质)
  - [二叉树的概念](#二叉树的概念)
  - [二叉树的性质](#二叉树的性质)
  - [二叉树的存储结构](#二叉树的存储结构)
  - [二叉树的遍历和线索二叉树](#二叉树的遍历和线索二叉树)
  - [树的存储结构](#树的存储结构-)
  - [树、森林、二叉树的转换](#树--森林--二叉树的转换-)
  - [树与森林的遍历](#树与森林的遍历-)
  - [树与二叉树的应用](#树与二叉树的应用)
- [图](#图)
  - [图的基本概念](#图的基本概念)
  - [图的存储及基本操作](#图的存储及基本操作)
  - [图的遍历](#图的遍历)
  - [图的应用](#图的应用)
  - [有向无环图描述表达式（DAG）](#有向无环图描述表达式dag)
  - [拓扑排序](#拓扑排序)
  - [关键路径](#关键路径)
- [查找](#查找)
  - [1. 基本概念](#1-基本概念)
  - [2. 线性结构](#2-线性结构)
  - [3. 树形结构](#3-树形结构)
  - [4. 散列结构——散列表](#4-散列结构散列表)
  - [5. 效率指标——平均查找长度 (ASL)](#5-效率指标平均查找长度-asl)
- [排序](#排序)
  - [1. 基本概念](#1-基本概念-1)
  - [2. 内部排序](#2-内部排序)
  - [3. 外部排序](#3-外部排序) -->

## 绪论 — 基础与要点
- **定义**：数据结构是组织数据、存储数据并为数据操作提供效率保证的方式，常与算法配合解决问题。
- **抽象数据类型（ADT）**：对数据的逻辑描述与允许的操作（例如：线性表、栈、队列、集合、映射、树、图），实现可变（数组、链表、哈希等）。
- **逻辑结构**：描述元素之间关系的抽象形式（线性、树形、图形、集合）。
- **存储结构**：指物理实现方式，常见有：
  - 顺序存储（数组）：随机访问 O(1)，但中间插入/删除需移动元素 O(n)。
  - 链式存储（链表）：插入删除在已知节点处 O(1)，但随机访问需 O(n)。
  - 散列（哈希表）/索引：用于快速查找，依赖哈希函数与冲突解决策略。
- **基本操作**：访问、查找、插入、删除、修改、遍历（不同结构对上述操作的复杂度不同）。
- **时间复杂度 / 空间复杂度**：使用大 O 表示法描述随输入规模 n 的增长趋势（最好/平均/最坏）。
  - 常见阶：O(1)、O(log n)、O(n)、O(n log n)、O(n^2)、O(2^n)
  - 常见规则：去掉常数、保留最高阶、相加取最大、嵌套循环相乘。
- **重要概念**：
  - **稳定性**（排序中相等元素是否保持原相对顺序）。
  - **原地（in-place）算法**（辅助空间为 O(1)）。
  - **递归栈空间**（递归消耗的栈空间要计入空间复杂度）。
  - **摊还分析**（如动态数组扩容的均摊复杂度）。

### 嵌套复杂度分析
在分析嵌套循环的时间复杂度时，最关键的是看**内层执行总次数的累加规律**。

---

#### 1. 核心判断逻辑
| 关系类型 | 特征 | 处理方法 |
| :------- | :-- | :------ |
| **独立关系** | 内层循环次数与外层变量 i 无关 | **直接相乘**：外层次数 × 内层次数 |
| **相关关系** | 内层循环次数随外层变量 i 变化 | **数列求和**：写出每一轮次数，求总和 S_n |

---

#### 2. 等比数列型（本题考点）
**特征：** 循环变量以翻倍（`i *= 2`）或折半（`i /= 2`）的方式变化。

##### 情况 A：内层随外层翻倍增长
- **代码示例：**
  ```cpp
  for (int i = 1; i < n; i *= 2)
      for (int j = 0; j < i; j++) // 内层执行 i 次
          sum++;
  ```
- **数列：** $1 + 2 + 4 + 8 + \dots + 2^k$ （其中 $2^k < n$）
- **结论：** **$O(n)$**
- **秒杀技巧：** 增长极快，总量被最后一项 n 统治，总和约等于 2n。

##### 情况 B：内层随外层折半减少
- **代码示例：** 快速选择算法（Quick Select）
- **数列：** $n + n/2 + n/4 + \dots + 1$
- **结论：** **$O(n)$**
- **秒杀技巧：** 这是一个收敛数列，总和永远不会超过 2n。

---

#### 3. 等差数列型
**特征：** 循环变量以恒定步长（`i++` 或 `i += 2`）增加。

- **代码示例：**
  ```cpp
  for (int i = 0; i < n; i++)
      for (int j = 0; j < i; j++) // 内层依次执行 1, 2, 3...n 次
          sum++;
  ```
- **数列：** $1 + 2 + 3 + \dots + n$
- **公式：** $S_n = \frac{n(1+n)}{2}$
- **结论：** **$O(n^2)$**
- **秒杀技巧：** 均匀增长，像一个三角形，面积是底 × 高的一半，量级为 n^2。

---

#### 4. 常见陷阱对比
| 代码片段 | 复杂度 | 原因 |
| :------- | :----- | :-- |
| `i < n; i *= 2` { `j < i; j++` } | **$O(n)$** | 等比数列求和，最后一项统治总量。 |
| `i < n; i *= 2` { `j < n; j++` } | **$O(n \log n)$** | 独立关系，外层 log n 次，内层每次固定 n 次。 |
| `i < n; i++` { `j < i; j++` } | **$O(n^2)$** | 等差数列求和。 |

---

> **复习金句：**
> - **翻倍看末项：** 只要是翻倍增长的累加，结果就是最后一项的量级 O(n)。
> - **匀速看平方：** 只要是匀速增长的累加，结果就是平方量级 O(n^2)。

---
## 线性表
定义：线性表是一种数据结构，其中元素按顺序排列，每个元素（除第一个和最后一个）都有唯一的前驱和后继。
- **顺序存储结构**：使用数组实现，支持随机访问，插入和删除操作较慢。起始位置加上索引即可访问元素。需要连续的存储空间。
- **链式存储结构**：使用节点和指针实现，插入和删除操作较快，但随机访问较慢。因为要遍历链表才能找到特定位置的元素。不需要连续存储空间。
- **基本操作**：
  - 访问元素：通过索引或指针访问特定位置的元素。
  - 插入元素：在指定位置插入新元素。
  - 删除元素：删除指定位置的元素。
  - 查找元素：根据值查找元素的位置。
  - 遍历线性表：依次访问所有元素。  
线性表元素的序号从1开始，到n结束，共有n个元素。




### 顺序表
定义：线性表的一种顺序存储结构，使用连续的内存空间存储元素。
- **优点**：支持随机访问，空间利用率高。
- **缺点**：插入和删除操作需要移动大量元素，空间扩展困难。
- **基本操作复杂度**：
  - 访问元素：O(1)
  - 插入元素：O(n)（最坏情况）
  - 删除元素：O(n)（最坏情况）
  - 按值查找元素：O(n)
  - 遍历线性表：O(n)

顺序表的存储空间 = 表长度 × 元素大小 + 常数开销

### 链表
定义：线性表的一种链式存储结构，由节点组成，每个节点包含数据域和指针域。
- **单链表**：每个节点包含一个指向下一个节点的指针。
- **双链表**：每个节点包含两个指针，分别指向前一个和后一个节点。
- **循环链表**：最后一个节点指向第一个节点，形成环状。
- **优点**：插入和删除操作高效，不需要连续存储空间。
- **缺点**：随机访问效率低，额外的指针空间开销。
- **基本操作复杂度**：
  - 访问元素：O(n)
  - 插入元素：O(1)（在已知位置）
  - 删除元素：O(1)（在已知位置）
  - 按值查找元素：O(n)
  - 遍历线性表：O(n)
  - 头插法与尾插法：O(1) 插入新节点到链表头或尾。
- **链表的存储空间** = 节点数 × (数据域大小 + 指针域大小) + 常数开销

循环链表的尾节点指针指向头节点，实现循环访问。
循环单链表：尾节点的指针指向头节点，实现循环访问。
若设头节点，在表尾插入节点时，需遍历链表找到尾节点，时间复杂度为 O(n)。
若设尾节点指针，则表头表尾插入操作可在 O(1) 时间内完成。

循环双链表：容易推导出类似的结论。

静态链表：使用数组模拟链表结构，通过数组下标作为指针，实现链式存储的效果。适用于不支持动态内存分配的环境。静态链表以 next = -1 作为结束标志。

### 顺序表与链表的比较
1. 存取方式
   - 顺序表：支持随机访问，通过索引直接访问元素，时间复杂度为 O(1)。
   - 链表：不支持随机访问，需要从头节点开始遍历，时间复杂度为 O(n)。
2. 逻辑结构与物理结构
   - 顺序表：逻辑结构与物理结构一致，元素按顺序存储在连续的内存空间中。
   - 链表：逻辑结构与物理结构不一致，元素通过指针连接，存储在非连续的内存空间中。
3. 查找、插入、删除操作
   - 顺序表：按序号查找操作时间复杂度为 O(1)，插入和删除操作时间复杂度为 O(n)（最坏情况）。
   - 链表：查找操作时间复杂度为 O(n)，插入和删除操作时间复杂度为 O(1)（在已知位置）。
4. 空间分配
   - 顺序表：需要连续的存储空间，可能导致内存碎片化，扩展困难。
   - 链表：不需要连续的存储空间，动态分配内存。

## 栈与队列
### 栈
定义：栈是一种线性数据结构，遵循后进先出（LIFO）原则。即最后插入的元素最先被删除。
- **基本操作**：
  - 入栈（Push）：将元素添加到栈顶。
  - 出栈（Pop）：删除并返回栈顶元素。
  - 访问栈顶元素（Peek/Top）：返回栈顶元素但不删除。
  - 判空（IsEmpty）：检查栈是否为空。
- **性质**：第 n 个卡特兰数 C_n，即 $C_n = \frac{1}{n+1} \binom{2n}{n}$，表示长度为 2n 的合法括号序列的数量。 当 n 个不同元素入栈时，满足出栈序列合法的方案数为 C_n。

#### 栈的顺序存储结构
1. 顺序栈的实现：
   - 使用数组实现栈结构，栈顶指针指向当前栈顶元素的位置。
   - 栈顶指针初始化为 -1，表示栈为空。
   - 入栈操作：将栈顶指针加 1，并将新元素存储在栈顶位置。
   - 出栈操作：返回栈顶元素，并将栈顶指针减 1。
   - 判空操作：检查栈顶指针是否为 -1。
2. 基本操作：
   - 初始化栈：O(1)
   - 入栈操作：O(1)
   - 出栈操作：O(1)
   - 访问栈顶元素：O(1)
   - 判空操作：O(1)
3. 共享栈
   - 使用一个数组实现两个栈，分别从数组的两端向中间增长。
   - 需要两个栈顶指针，分别指向两个栈的栈顶位置。
   - 入栈操作：根据栈号选择相应的栈顶指针进行操作。
   - 出栈操作：根据栈号选择相应的栈顶指针。
4. 栈的链式存储结构
   - 使用链表实现栈结构，每个节点包含数据域和指针域。
   - 栈顶指针指向链表的头节点。
   - 入栈操作：创建新节点，将其指针域指向当前栈顶节点，然后更新栈顶指针指向新节点。
   - 出栈操作：返回栈顶节点的数据域，并将栈顶指针更新为下一个节点。
   - 判空操作：检查栈顶指针是否为 NULL。

### 队列
定义：队列是一种线性数据结构，遵循先进先出（FIFO）原则。即最先插入的元素最先被删除。
- **基本操作**：
  - 入队（Enqueue）：将元素添加到队尾。
  - 出队（Dequeue）：删除并返回队头元素。
  - 访问队头元素（Front/Peek）：返回队头元素但不删除。
  - 判空（IsEmpty）：检查队列是否为空。

#### 队列的顺序存储结构
1. 顺序队列的实现：
   - 使用数组实现队列结构，维护两个指针：队头指针和队尾指针。
   - 队头指针指向队头元素的位置，队尾指针指向下一个可插入位置。
   - 入队操作：将新元素存储在队尾位置，并将队尾指针加 1。
   - 出队操作：返回队头元素，并将队头指针加 1。
   - 判空操作：检查队头指针是否等于队尾指针。
2. 循环队列：
   - 为了解决顺序队列的空间浪费问题，使用循环数组实现队列结构。
   - 队头和队尾指针在数组中循环移动，当队尾指针到达数组末尾时，下一次入队操作将其移动到数组开头。
   - 入队和出队操作与顺序队列类似，但需要使用取模运算来处理循环。
   - 特定条件下循环队列队头队尾指针的初值：
     - 初始时：Q.front = Q.rear = 0
   - 队首指针进 1：Q.front = (Q.front + 1) % MaxSize
   - 队尾指针进 1：Q.rear = (Q.rear + 1) % MaxSize
   - 队列长度：(Q.rear - Q.front + MaxSize) % MaxSize
   - 特定情况下循环队列判空与判满条件：
     - 队列为空：Q.front == Q.rear
     - 队满情况：(Q.rear + 1) % MaxSize == Q.front
   - 元素个数：(Q.rear - Q.front + MaxSize) % MaxSize
   - 牺牲一个队列单元来区分队满与队空的状态。
   - Q.rear 指向队尾元素的下一个位置。
3. 基本操作：
   - 初始化队列：O(1)
   - 入队操作：O(1)
   - 出队操作：O(1)
   - 访问队头元素：O(1)
   - 判空操作：O(1)

### 队列的链式存储结构
- 使用链表实现队列结构，维护两个指针：队头指针和队尾指针。
- 队头指针指向链表的头节点，队尾指针指向链表的尾节点。
- 入队操作：创建新节点，将其指针域设置为 NULL，并将当前队尾节点的指针域指向新节点，然后更新队尾指针指向新节点。
- 出队操作：返回队头节点的数据域，并将队头指针更新为下一个节点。
- 判空操作：检查队头指针是否为 NULL。

### 双端队列
定义：双端队列（Deque）是一种线性数据结构，允许在两端进行插入和删除操作。
- **基本操作**：
  - 前端入队（EnqueueFront）：将元素添加到队列前端。
  - 后端入队（EnqueueRear）：将元素添加到队列后端。
  - 前端出队（DequeueFront）：删除并返回队列前端的元素。
  - 后端出队（DequeueRear）：删除并返回队列后端的元素。
  - 访问前端元素（Front/PeekFront）：返回前端元素但不删除。
  - 访问后端元素（Rear/PeekRear）：返回后端元素但不删除。
  - 判空（IsEmpty）：检查双端队列是否为空。

在 C++ 中，双端队列可以使用 STL 提供的 `deque` 容器实现，支持高效的两端插入和删除操作。示例：
```cpp
#include <deque>
std::deque<int> dq; // 创建双端队列
dq.push_front(10); // 前端入队
dq.push_back(20);  // 后端入队
int front = dq.front(); // 访问前端元素
int rear = dq.back();   // 访问后端元素
dq.pop_front(); // 前端出队
dq.pop_back();  // 后端出队
bool isEmpty = dq.empty(); // 判空
```

> 输入受限双端队列（一端进、两端出）: 不存在极大值
>
> 输出受限双端队列（两端进、一端出）: 不存在极小值

---

### 栈和队列的应用
#### 括号匹配
- 使用栈来检查括号是否匹配。遍历字符串，遇到左括号时入栈，遇到右括号时出栈并检查是否匹配；最终栈为空表示匹配成功。

#### 表达式求值 — 中缀到后缀（逆波兰）
- 概念：
  - **中缀表达式**：操作符位于操作数之间（如 a + b），常见但解析时需处理括号与优先级。
  - **后缀表达式（逆波兰）**：操作符写在操作数之后（如 a b +），无需括号，便于用栈计算。

- 转换（中缀 -> 后缀）算法要点：
  1. 初始化：空栈 S（运算符），空输出序列 P。
  2. 从左到右扫描每个 token：
     - 若为操作数：将其输出到 P。
     - 若为左括号 '(': 将其压入 S。
     - 若为右括号 ')': 依次弹出 S 顶部的运算符并输出到 P，直到弹出左括号 '(', 丢弃该左括号。
     - 若为运算符 op：
       - 当 S 非空且 S.top 为运算符且（优先级(S.top) > 优先级(op) 或者 优先级相等且 op 为左结合）时，弹出 S.top 并输出到 P（处理结合性时，右结合运算符如 ^ 应使用 “>” 而非 “>=”）。
       - 将 op 压入 S。
  3. 扫描结束后，将 S 中剩余的运算符依次弹出并输出到 P（遇到括号则为非法表达式）。

- 例子：
  - 中缀： A + B * C ——> 后缀： A B C * +
  - 中缀： (A + B) * C ——> 后缀： A B + C *

- 后缀表达式求值（使用栈）：
  1. 从左到右扫描后缀表达式的每个 token。
  2. 若为操作数：将其入栈。
  3. 若为运算符：弹出相应个数的操作数（通常为两个），执行运算，将结果入栈。
  4. 扫描结束后，栈顶即为表达式值（栈应只剩一个元素，否则表达式非法）。

#### 栈的在递归中的应用
- 递归调用本质上使用了系统栈来保存函数调用信息（参数、返回地址、本地变量）。
- 手动模拟递归：使用显式栈结构来保存函数调用状态，避免系统栈溢出。
#### 队列在层次遍历中的应用
- 使用队列实现二叉树的层次遍历（广度优先遍历）。
- 算法步骤：
  1. 初始化一个空队列，将根节点入队。
  2. 当队列不为空时：
     - 出队一个节点，访问该节点。
     - 若该节点有左子节点，则将左子节点入队。
     - 若该节点有右子节点，则将右子节点入队。
- 该方法确保节点按层次顺序被访问。
#### 队列在计算机系统的应用
- 任务调度：操作系统使用队列管理进程和线程的执行顺序。
- 缓冲区管理：网络数据包的发送和接收通常使用队列来缓存数据。
- 打印任务管理：打印机使用队列来管理打印任务的顺序。

## 数组与特殊矩阵
### 数组
定义：数组是一种线性数据结构，由一组具有相同数据类型的元素组成，这些元素在内存中连续存储，并通过索引进行访问。
### 数组的存储结构
- **顺序存储结构**：数组元素在内存中连续存储，支持随机访问。通过数组名和索引计算元素地址。
- **多维数组**：通过行优先或列优先方式存储，常见为行优先存储。地址计算公式：
  - 行优先：`address = base_address + (i * num_columns + j) * element_size`
  - 列优先：`address = base_address + (j * num_rows + i) * element_size`
### 特殊矩阵的特殊压缩
1.对称矩阵
定义：矩阵 A 满足 A[i][j] = A[j][i]，只需存储上三角或下三角部分。
存储方式：使用一维数组存储上三角部分，索引计算公式：
(1<=i,j<=n 且 i<=j)
k=i(i-1)/2+j-1，i>=j(下三角区和主对角线元素)
k=j(j-1)/2+i-1，j>i (上三角区元素)
2.三角矩阵
分为上三角矩阵和下三角矩阵，需要会求元素下标的对应方式
3.三对角矩阵
定义：矩阵 A 仅在主对角线及其上下各一条对角线上有非零元素。
存储方式：使用一维数组分别存储主对角线、上对角线和下对角线的元素。行优先。
4.稀疏矩阵
用三元组（行、列、值）存储非零元素，节省空间。
存储方式：使用数组或链表f储三元组，按行或列排序以便快速访问。
缺点：访问元素需遍历三元组，效率较低。失去了随机存取特性。
## 串
### 串的定义和实现
#### 定义
串是一种线性数据结构，由一组有序的字符组成，用于表示文本信息。串中的字符可以是字母、数字、符号或其他字符。
#### 基本操作
赋值：将一个串的内容复制到另一个串中。strcpy(dest, src)
连接：将两个串连接成一个新的串。strcat(dest, src)
比较：比较两个串的大小关系。strcmp(str1, str2)
求长度：计算串中字符的个数。strlen(str) 
查找子串：在一个串中查找另一个串的位置。strstr(haystack, needle)
插入子串：在指定位置插入一个子串。
### 串的存储结构
1.定长顺序存储结构
- 使用固定长度的数组存储串，适用于长度已知且变化不大的情况。
- 优点：访问速度快，空间利用率高。    
2.堆分配存储结构
- 动态分配内存，根据实际需要分配空间，适用于长度变化较大的情况。
- 优点：节省内存空间，灵活性高。  
### 串的模式匹配
#### 朴素模式匹配算法
- 基本思想：从主串的每个位置开始，逐个字符与模式串进行比较，直到找到匹配或遍历完整个主串。
- 时间复杂度：O(m * n)，其中 m 是主串长度，n 是模式串长度。
#### KMP 算法（Knuth-Morris-Pratt）
- 基本思想：通过预处理模式串，构建部分匹配表（next 数组），在匹配过程中利用已匹配的信息，避免重复比较。
- 预处理阶段：计算模式串的部分匹配表 next 数组。  
- 匹配阶段：使用主串和模式串进行匹配，遇到不匹配时，根据 next 数组调整模式串的位置。
- 时间复杂度：O(m + n)，其中 m 是主串长度，n 是模式串长度。
- next 数组的构建：
1. 初始化：next[0] = -1，i = 0，j = -1。
2. 遍历模式串：
   - 若 j == -1 或模式串[i] == 模式串[j]，则 i++，j++，设置 next[i] = j。
   - 否则，设置 j = next[j].
  
## 树与二叉树
### 树的基本概念
定义：树是一种非线性数据结构，由节点组成，节点之间通过边连接，具有层次关系。树的特点包括：
- 根节点：树的顶端节点，没有父节点。
- 叶节点：没有子节点的节点。
- 子节点：某节点直接连接的下级节点。
- 父节点：某节点直接连接的上级节点。
### 基本术语
1.祖先，子孙，双亲，孩子，兄弟和堂兄弟：
- 祖先：从根节点到某节点路径上的所有节点。
- 子孙：某节点的所有后代节点。
- 双亲：某节点的直接上级节点。
- 孩子：某节点的直接下级节点。
- 兄弟：具有相同父节点的节点。
- 堂兄弟：父节点是兄弟节点的节点。
2.度，路径，层次，深度，高度：
- 度：节点的子节点数量。
- 路径：从一个节点到另一个节点经过的边的序列。
- 层次：节点所在的层级，根节点为第 1 层。
- 深度：节点到根节点的路径长度。
- 高度：节点到叶节点的最长路径长度。
3.森林：
- 森林是由多棵互不相连的树组成的集合。
### 树的性质
1.树的结点数n等于所有结点的度数之和加1。
结点的度是指该节点的孩子数量，所有节点的度数之和等于边数之和，而一棵树的边数等于结点数减1，因此 n = (度数之和) + 1。
2.在一棵有 n 个结点的树中，若每个结点的度都不小于 k (k≥1)，则树的高度至少为 logk(n(k-1)+1)。
这是因为每增加一层，结点数至少增加 k 倍，因此高度 h 满足 k^h ≥ n(k-1)+1，解出 h 可得上述不等式。
3.在一棵有 n 个结点的 m 叉树中，若所有叶结点都在第 h 层上，则该树的结点数 n 满足 n = (m^h - 1) / (m - 1)。
这是因为每层结点数按 m 的幂次增长，前 h 层的结点数之和即为上述公式。
4.度为m的树中第i层上至多有 m^(i-1) 个结点（i≥1）。
这是因为每增加一层，结点数最多增加 m 倍，因此第 i 层的结点数最多为 m 的 (i-1) 次方。
5.9 logm(n(m-1)+1)。最大高度h=n-m+1。
这是因为每增加一层，结点数至少增加 m 倍，因此高度 h 满足 m^h ≥ n(m-1)+1，解出 h 可得上述不等式。最大高度发生在每个节点只有一个子节点的情况下。此时，树退化为链表，高度为 n - m + 1。
### 二叉树的概念
#### 二叉树的定义及其主要特性
1.二叉树的定义：
- 二叉树是一种特殊的树结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。
- 二叉树是有序数，其子节点有明确的顺序（左、右）。
二叉树与度为2的有序树的区别：
- 度为2的树至少有三个结点，而二叉树可以为空。
- 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则无法区分是左孩子还是右孩子，而二叉树的每个结点的孩子都有明确的左右之分。

2.几种特殊的二叉树
a.满二叉树：
- 定义：每个节点要么是叶节点，要么有两个子节点，且所有叶节点都在同一层。
- 性质：高度为 h 的满二叉树有 2^h-1个结点，可以按层序编号，约定编号从 1 开始。自上而下，从左到右。对于编号为i的结点：
  - 左孩子编号为 2i
  - 右孩子编号为 2i + 1
  - 父节点编号为 floor(i/2)
b.完全二叉树：
- 定义：除最后一层外，其他层的节点都达到最大值，且最后一层的节点从左到右连续排列。
- 性质：高度为 h 的完全二叉树至少有 2^(h-1) 个结点，至多有 2^h - 1 个结点。
c.二叉排序树：
左子树上的所有结点的关键字均小于跟结点的关键字；右子树上所有节点的关键字均大于根结点的关键字；左子树和右子树又各是一颗二叉排序树。
d.平衡二叉树：
树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。示意图如下：
          A
          / \
        B   C
        / \   \
      D   E   F 
e.正则二叉树：
树中每个分支结点都有2个孩子，即树中只有度为0或2的结点。

3.二叉树的性质
a.在一棵非空二叉树中，若叶结点数为 n0，度为2的结点数为 n2，则有 n0 = n2 + 1。
证明：
设二叉树中度为1的结点数为 n1，总结点数为 n，则有 n = n0 + n1 + n2。
二叉树的边数为 n - 1，根据边数与度数的关系，有：
n - 1 = n1 + 2n2 从而得到 n0 = n2 + 1。
b.在一棵二叉树中，第 i 层上至多有 2^(i-1) 个结点（i≥1）。
证明：
每增加一层，结点数最多增加 2 倍，因此第 i 层的结点数最多为 2 的 (i-1) 次方。
c.高度为 h 的二叉树至多有 2^h - 1 个结点。
等比数列求和的结果
d.具有n个结点的二叉树的最小高度为 log2(n+1)向上取整，最大高度为 n。
如果要容纳 $n$ 个结点，则高度为 $h$ 的二叉树必须满足：$$2^{h-1} - 1 < n \le 2^h - 1$$
最大高度：当二叉树退化为单支树（类似于链表）时，高度最大，为 $n$。最小高度：当二叉树为完全二叉树或满二叉树时，高度最小，为 $\lceil \log_2(n+1) \rceil$ （或表示为 $\lfloor \log_2 n \rfloor + 1$）。
### 二叉树的存储结构
1.顺序存储结构
- 使用数组存储二叉树节点，适用于完全二叉树。
2.链式存储结构
- 使用节点和指针存储二叉树，适用于一般二叉树。
- 在含有n个结点的二叉链表中，指针域总共占用 2n 个存储单元。含有n+1个空链接域。
### 二叉树的遍历和线索二叉树
#### 二叉树的遍历
1.前序遍历（Preorder Traversal）
- 访问顺序：根节点 -> 左子树 -> 右子树
- 递归实现：
```cpp
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->val << " ";
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}
```
2.中序遍历（Inorder Traversal）
- 访问顺序：左子树 -> 根节点 -> 右子树 
- 递归实现：
```cpp
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->val << " ";
    inorderTraversal(root->right);
}
```
3.后序遍历（Postorder Traversal）
- 访问顺序：左子树 -> 右子树 -> 根节点
- 递归实现：  
```cpp
void postorderTraversal(TreeNode* root) { 
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->val << " ";
}
```
4.层次遍历（Level Order Traversal）
- 访问顺序：按层次从上到下、从左到右访问
- 使用队列实现：
```cpp
void levelOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    queue<TreeNode*> q;// 创建一个队列
    q.push(root);// 将根节点入队
    while (!q.empty())  // 当队列不为空时
    {
        TreeNode* node = q.front();// 获取队头节点
        q.pop();  // 出队
        cout << node->val << " ";// 访问节点
        if (node->left) q.push(node->left);// 将左子节点入队
        if (node->right) q.push(node->right);// 将右子节点入队
    }
}
```
5.由遍历序列构造二叉树
a. 先序和中序构造二叉树
构造思路：
- 先序序列的第一个元素为根节点。
- 在中序序列中找到根节点的位置，可将中序序列划分为左子树和右子树两部分。
- 根据左子树大小，再从先序序列中划分出左右子树对应的先序子序列，递归构造。

代码实现（简单切片版，清晰但会产生额外拷贝）：
```cpp
// 构造二叉树：给定先序(preorder)和中序(inorder)遍历序列，返回构造的树的根节点
TreeNode* buildTreePreIn(vector<int>& preorder, vector<int>& inorder) {
    if (preorder.empty() || inorder.empty()) return nullptr; // 终止条件
    int rootVal = preorder[0]; // 先序首元素为根
    TreeNode* root = new TreeNode(rootVal);
    auto it = find(inorder.begin(), inorder.end(), rootVal); // 在中序中查找根
    int leftSize = distance(inorder.begin(), it); // 左子树节点数
    vector<int> leftInorder(inorder.begin(), it);
    vector<int> rightInorder(it + 1, inorder.end());
    vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + 1 + leftSize);
    vector<int> rightPreorder(preorder.begin() + 1 + leftSize, preorder.end());
    root->left = buildTreePreIn(leftPreorder, leftInorder);
    root->right = buildTreePreIn(rightPreorder, rightInorder);
    return root;
}
```

优化建议（O(n) 时间、O(n) 额外空间）：使用哈希表缓存中序值->索引，避免每次查找和切片。
```cpp
#include <unordered_map>

TreeNode* buildTreePreInFast(const vector<int>& preorder, const vector<int>& inorder) {
    unordered_map<int,int> idx; // 值 -> 在中序中的下标
    for (int i = 0; i < (int)inorder.size(); ++i) idx[inorder[i]] = i;
    // 递归 lambda：preorder 区间 [pl, pr], inorder 区间 [il, ir]
    function<TreeNode*(int,int,int,int)> dfs = [&](int pl, int pr, int il, int ir) -> TreeNode* {
        if (pl > pr || il > ir) return nullptr;
        int rootVal = preorder[pl];
        TreeNode* root = new TreeNode(rootVal);
        int k = idx[rootVal]; // 中序中根的位置
        int leftSize = k - il;
        root->left = dfs(pl + 1, pl + leftSize, il, k - 1);
        root->right = dfs(pl + leftSize + 1, pr, k + 1, ir);
        return root;
    };
    return dfs(0, (int)preorder.size() - 1, 0, (int)inorder.size() - 1);
}
```
复杂度：时间 O(n)，空间 O(n)（哈希表 + 递归栈）。注意：要求节点值互不相同才能用哈希表映射。

---

b. 后序和中序构造二叉树
构造思路：
- 后序序列的最后一个元素为根节点。
- 在中序序列中找到根的位置，划分左右子树；左子树大小决定后序中左子树的范围。

代码实现（O(n) 优化版，使用哈希表）：
```cpp
TreeNode* buildTreePostInFast(const vector<int>& postorder, const vector<int>& inorder) {
    unordered_map<int,int> idx;
    for (int i = 0; i < (int)inorder.size(); ++i) idx[inorder[i]] = i;
    function<TreeNode*(int,int,int,int)> dfs = [&](int pl, int pr, int il, int ir) -> TreeNode* {
        if (pl > pr || il > ir) return nullptr;
        int rootVal = postorder[pr]; // 后序最后一个为根
        TreeNode* root = new TreeNode(rootVal);
        int k = idx[rootVal];
        int leftSize = k - il;
        root->left = dfs(pl, pl + leftSize - 1, il, k - 1);
        root->right = dfs(pl + leftSize, pr - 1, k + 1, ir);
        return root;
    };
    return dfs(0, (int)postorder.size() - 1, 0, (int)inorder.size() - 1);
}
```


#### 线索二叉树
基本概念：
- 线索二叉树是一种特殊的二叉树，利用空指针存储前驱和后继节点的信息，以便于遍历。 （通常不考）


### 树的存储结构
下面列出常见的三种树的存储方法及其要点、优缺点与适用场景：

1. **孩子表示法（Child list / children array）**
   - 描述：每个结点保存其所有孩子的引用，可用数组（定度 m）或链表（不定度）实现。
   - 实现要点：
     - 定度树（m 叉树）：直接使用长度为 m 的 children 数组。
     - 不定度树：用链表/向量保存孩子列表。
   - 优点：按孩子索引访问速度快（数组），遍历孩子顺序直观。
   - 缺点：数组会浪费空间；链表访问第 k 个孩子需要 O(k)。
   - 复杂度示意：插入第一个孩子 O(1)，随机访问第 k 个孩子 O(1)（数组）或 O(k)（链表）。
   - 适用场景：节点度有上界且需要按索引快速访问孩子的场景。

   - 示意图（m=3 的孩子数组）：
     ```text
         A
        /|\
       B C D

     A.children = [B, C, D]
     ```

2. **双亲表示法（Parent representation）**
   - 描述：每个结点只存储指向父节点的指针或父节点索引（例如 parent[i] = 父节点索引）。
   - 实现要点：通常用数组 parent[n]，根节点 parent[root] = -1。
   - 优点：占用空间少（每结点一指针），方便快速向上查询父节点或计算深度。
   - 缺点：不方便枚举孩子（需遍历所有结点查找父为某值，成本 O(n)）。
   - 适用场景：以父向上操作为主的静态树或并查类问题。

   - 示意图与数组表示：
     ```text
     节点索引: 0  1  2  3
     节点值:  A  B  C  D
     parent:  -1 0  0  1   // B 的父是 A (0), C 的父是 A (0), D 的父是 B (1)
     ```

3. **孩子-兄弟表示法（Left-child Right-sibling）**
   - 描述：把通用树转换为二叉树的常用方法，每个结点保存指向“第一个孩子（firstChild）”和“下一个兄弟（nextSibling）”的指针。
   - 实现要点：使用两个指针（或数组索引）维护 firstChild 和 nextSibling。
   - 优点：存储紧凑，能够用二叉树的算法处理通用树，遍历所有孩子线性高效。
   - 缺点：访问第 k 个孩子仍需遍历 k 步；语义上比直接孩子列表稍复杂。
   - 适用场景：度不固定且希望复用二叉树算法或节省存储时。

   - 原始树示意：
     ```text
         A
        / \
       B   C
      / \   \
     D   E   F
     ```

   - 孩子-兄弟表示的指针关系（可视为二叉树）：
     ```text
     A
     └─ firstChild -> B
        B
        ├─ firstChild -> D
        └─ nextSibling -> C
           C
           └─ firstChild -> F
     D -> nextSibling -> E
     ```

   - 小贴士：对这种表示法做前序/遍历时，等价于对原树的先序遍历：
     - 访问节点 -> 递归访问 firstChild 子树 -> 递归访问 nextSibling

#### 树、森林、二叉树的转换

1. **树 -> 二叉树（孩子-兄弟变换）**
   - 思路：对每个结点，令其“第一个孩子”作为左子节点（left），其“下一个兄弟”作为右子节点（right）。这样任意多叉树可以被转为二叉树。
   - 示意：
     ```text
     原始树：           转换后二叉树：
         A                 A
        / \               / \
       B   C             B   (sibling)
      / \   \           / \
     D   E   F         D   C
                         \   \
                          E   F
     ```
   - 伪代码：
     ```text
     function toBinary(node):
         if node == null: return null
         b = new BNode(node.val)
         b.left = toBinary(node.firstChild)
         b.right = toBinary(node.nextSibling)
         return b
     ```
   - 复杂度：O(n) 时间，递归栈 O(h)。

2. **森林 -> 二叉树**
   - 思路 A（推荐）：把森林看作加一个虚拟根（其孩子为各棵树的根）的树，然后对该树做孩子-兄弟变换。
   - 思路 B：把森林中各根按兄弟链联起来，直接当作孩子-兄弟表示的首层。
   - 注意：如果使用虚拟根，逆变换时需去掉该虚拟结点以恢复森林。

3. **二叉树 -> 树/森林（逆变换）**
   - 思路：将二叉树的 left 指针视为第一个孩子，right 指针视为下一个兄弟；按这个规则恢复通用树的孩子链。
   - 伪代码：
     ```text
     function toGeneral(node):
         if node == null: return null
         t = new Node(node.val)
         t.firstChild = toGeneral(node.left)
         // 恢复兄弟链：
         child = t.firstChild
         while child != null:
             child.nextSibling = toGeneral(child.right)
             child = child.nextSibling
         return t
     ```
   - 常见错误：把 right 误当作“右子树”访问，导致丢失兄弟关系；逆变换中未处理虚拟根会把森林当作单棵树。

---

#### 树与森林的遍历

- **通用树（多叉树）遍历**：
  - 先序（前序）：访问节点 -> 依次遍历每个孩子（按顺序）。
    ```text
    preorder(node):
      if node == null: return
      visit(node)
      for child in node.children: preorder(child)
    ```
  - 后序：先遍历孩子 -> 访问节点。
  - 层次（BFS）：使用队列，将根入队，依次出队并把该节点的所有孩子依次入队。

- **森林遍历**：对森林中的每个根依次执行所需的树遍历（先序/后序/BFS 等）。

- **孩子-兄弟表示下的遍历对应关系**：
  - 在孩子-兄弟表示上做前序（访问、左、右）等价于原树的先序（访问、遍历 firstChild 链再遍历兄弟）。
  - BFS 要确保把“所有孩子”入队（在孩子-兄弟结构中需沿 nextSibling 遍历并入队）。
### 树与二叉树的应用
#### 哈夫曼树与哈夫曼编码

**相关概念**：
1. **结点的权**：通常是字符出现的频率或权重。
2. **带权路径长度（WPL）**：所有叶节点的（权 × 从根到该叶的路径长度）之和，哈夫曼树能使 WPL 最小。

**哈夫曼树的构造（贪心 + 最小堆）**：
1. 初始化：把每个字符及其权值构造成叶结点，放入一个最小堆（按权值）。
2. 重复直到堆中只剩一个结点：
   - 取出堆中权值最小的两个结点 A、B。
   - 新建结点 P，P.left = A, P.right = B，P.weight = A.weight + B.weight。
   - 将 P 插回堆中。
3. 堆中最后剩下的结点即为哈夫曼树的根。

**从树生成编码**：
- 从根出发，向左分支记 `0`，向右分支记 `1`，到达叶节点则得到该字符的二进制编码（前缀码，无歧义）。

**示例（经典）**：字符权值 {A:5, B:9, C:12, D:13, E:16, F:45}
- 构造合并过程（按权值取最小）：
  - 合并 A(5) + B(9) -> X(14)
  - 合并 C(12) + D(13) -> Y(25)
  - 合并 X(14) + E(16) -> Z(30)
  - 合并 Y(25) + Z(30) -> W(55)
  - 合并 F(45) + W(55) -> Root(100)

- 合并示意图（最终哈夫曼树）：
```
                 Root(100)
                /         \
             F(45)        W(55)
                         /      \
                      Y(25)     Z(30)
                     /   \     /    \
                  C(12) D(13) X(14)  E(16)
                                / \
                             A(5)  B(9)
```

- 生成的一个可能编码（左0右1）：
  - F: 0
  - C: 100
  - D: 101
  - A: 1100
  - B: 1101
  - E: 111

- 对应 WPL = 5*4 + 9*4 + 12*3 + 13*3 + 16*3 + 45*1 = 224

**伪代码（C++ 风格）**：
```cpp
struct Node { char ch; int w; Node *l, *r; Node(char c, int w): ch(c), w(w), l(nullptr), r(nullptr) {} };
struct cmp { bool operator()(Node* a, Node* b) const { return a->w > b->w; } };

// 构造哈夫曼树
priority_queue<Node*, vector<Node*>, cmp> pq;
for (auto [c,w] : symbols) pq.push(new Node(c,w));
while (pq.size() > 1) {
  Node* a = pq.top(); pq.pop();
  Node* b = pq.top(); pq.pop();
  Node* p = new Node('\0', a->w + b->w);
  p->l = a; p->r = b;
  pq.push(p);
}
Node* root = pq.top();

// 生成编码（递归）
void gen(Node* node, string code) {
  if (!node) return;
  if (node->ch != '\0') codes[node->ch] = code; // 叶节点
  gen(node->l, code + '0');
  gen(node->r, code + '1');
}

// 解码（按比特遍历树）
char decode(Node* root, const string& bits, int &pos) {
  Node* cur = root;
  while (cur->ch == '\0') {
    if (bits[pos] == '0') cur = cur->l; else cur = cur->r; pos++; }
  return cur->ch; }
```

**复杂度与空间**：
- 时间复杂度：使用最小堆构造为 O(n log n)（n 为字符种类）。
- 空间复杂度：O(n)（树结点与堆）。

**常见易错点**
- 忽略只有 1 个符号的特殊情况（应给其分配长度 1 的编码，如 `0`）。
- 以为哈夫曼编码在任意权重下都唯一：不同的合并顺序可能产生不同编码，但 WPL 最小值不变。
- 直接用字符频率生成编码时忘记处理字符数为 0 的情况或权值为 0 的符号。
- 实现时用字符串拼接生成编码效率较低，构造时可用字符数组或递归传引用以减少拷贝。

哈夫曼树常用二级结论（常见引理与性质）:

1. **二个最小权值的叶结点必为某最优哈夫曼树的一对兄弟结点（Siblings Lemma）**
   - 说明：若 a、b 为最小的两个权值，则存在最优树使它们成为一对兄弟（叶节点同父）。
   - 证明要点：把一棵最优树中任意两个权值不是兄弟但权小的叶结点交换位置，可降低或不增 WPL，从而可构造出满足条件的最优树。

2. **贪心选择正确性（合并最小两结点是安全操作）**
   - 说明：把最小的两个权值合并为新结点后，在新问题上构造最优树并展开，能得到原问题的最优解。
   - 证明要点：由第1条可得在某个最优解中最小两结点为兄弟，合并操作等价于把它们上抬一层，问题规模减一。

3. **哈夫曼树为满二叉树（除单符号特殊情况）**
   - 说明：每个非叶结点都有左右两个孩子，编码为前缀码且没有单支内结点（当符号数 > 1 时）。

4. **合并代价总和 = WPL（带权路径长度）**
   - 说明：构造时每次合并产生的权和累加起来等于最终码字总长度的带权和（WPL）。因此堆上每次取两最小权并累加，最后总和即 WPL。
   - 证明要点：每次合并相当于给被合并的叶节点深度增加 1，累加效果等价于 WPL。

5. **哈夫曼编码满足 Kraft 等式（前缀码性质）**
   - 说明：对于二进制编码，若所有叶构成一棵满二叉树，则满足 Σ 2^{-l_i} = 1（l_i 为各码长）。这是前缀码可行性条件之一。

6. **最优编码不唯一（权值相同或合并顺序不同）**
   - 说明：当存在相等权值或多种合并顺序时，可能有多棵不同形状的最优哈夫曼树，但它们的 WPL 相同。

7. **特殊情况处理**
   - 当只有 1 个符号时，应给其分配长度为 1 的码（例如 `0`），以便解码与规范化。

#### 并查集（Disjoint Set Union, DSU）

1. 概念：
   - 并查集是一种维护不相交集合（集合族）的数据结构，支持两项核心操作：
     - `find(x)`：查找元素 x 所在集合的代表元（根）。
     - `union(a, b)`：合并包含 a 和 b 的两个集合。
   - 常用于连通性判定、Kruskal 最小生成树、离线动态连通性、分组问题等。

2. 存储结构：
   - 常以数组实现：`parent[i]` 指向 i 的父节点，根节点 parent[root] = root（或 -1 表示根）；
   - 可额外维护 `sz[i]`（集合大小）或 `rank[i]`（秩）用于合并优化。

3. 基本实现与常用优化：
   - 基本模板（按大小合并 + 路径压缩）：
```cpp
struct DSU {
  vector<int> parent, sz;
  DSU(int n): parent(n), sz(n,1) { iota(parent.begin(), parent.end(), 0); }
  int find(int x) { return parent[x]==x ? x : parent[x] = find(parent[x]); }
  bool unite(int a, int b) {
    a = find(a); b = find(b); if (a==b) return false;
    if (sz[a] < sz[b]) swap(a,b);
    parent[b] = a; sz[a] += sz[b]; return true;
  }
};
```
   - 说明：`find` 使用路径压缩（递归或迭代），`union` 使用按大小/按秩合并，两者结合可使单次操作的摊还复杂度为 O(α(n))。

4. 复杂度：
   - 平均/摊还时间复杂度为 O(α(n))，几乎常数；空间 O(n)。

## 图
### 图的基本概念
#### 图的定义：
- 图是一种由节点（顶点）和连接节点的边组成的数据结构。
- 图可以是有向图（边有方向）或无向图（边无方向）。

#### 基本概念和术语（逐条说明）：
1. **有向图 (Directed graph)**：边有方向，边 (u->v) 表示从 u 指向 v；常见于建模单向关系（例如依赖、流向）。
   - 解题技巧：处理有向图时要区分入度与出度，多用入度数组判断拓扑排序的起点。
2. **无向图 (Undirected graph)**：边无方向，边 (u, v) 表示 u 与 v 相互连接；常见于关系或互通建模。
   - 解题技巧：连通性判断、最短路径（无向且无权时用 BFS）和欧拉路判定常在无向图中出现。
3. **简单图和多重图 (Simple vs Multigraph)**：简单图不允许自环或平行边；多重图允许多条同向/无向边。
   - 解题技巧：遇到多重边或自环时要特别小心计数、并查集与度数统计。
4. **顶点的度 / 入度 / 出度 (Degree / In-degree / Out-degree)**：无向图顶点的度；有向图的入度和出度。
   - 解题技巧：欧拉路径、拓扑排序、平衡性判定等常基于度的性质。
5. **路径 / 路径长度 / 回路 (Path / Length / Cycle)**：路径是顶点序列；长度通常为边数或权重之和；回路（环）表示起点=终点的路径。
   - 解题技巧：检测简单路径/简单回路常用 DFS（记录访问栈）；最短路径问题区分是否带权并选择算法。
6. **简单路径 / 简单回路 (Simple path / Simple cycle)**：路径中顶点互不重复（除回路首尾可能重合）。
7. **距离 (Distance)**：两点之间的最短路径长度（无权时以边数计，有权时以权和计）。
   - 解题技巧：无权用 BFS，有权（非负）用 Dijkstra，可能有负权则用 Bellman-Ford（检测负环）。
8. **子图 (Subgraph)**：由原图的顶点子集和在其间的边构成的图，诱导子图是由顶点子集自动包含两者间所有边的子图。
   - 解题技巧：构造子图用于缩小问题规模或求解连通分量/点割问题。
9. **联通 / 连通图 / 连通分量 (Connectivity / Connected component)**：无向图中顶点相互可达时称连通；不连通时把每个连通块称为连通分量（CC）。
   - 解题技巧：用 BFS/DFS 求连通分量，常用于连通性题、染色/二分图判定。
10. **强连通图 / 强连通分量 (SCC)**：有向图中任意两点互相可达称强连通；强连通分量是最大强连通子图。
    - 解题技巧：Kosaraju/Tarjan 可在 O(V+E) 求出所有 SCC，注意在缩点后把 SCC 当作 DAG 处理。
11. **生成树 / 生成森林 (Spanning tree / Spanning forest)**：连通无向图的一棵包含所有顶点且无环的子树。若图不连通则为生成森林。
    - 解题技巧：最小生成树（MST）类问题常用 Kruskal（边排序+并查集）或 Prim（优先队列）解决。
12. **边的权 / 带权路径长度 (Edge weight / Weighted path length)**：带权图中路径长度为边权之和，常用来衡量代价或距离。
13. **完全图 (Complete graph K_n)**：任意两顶点间都有边；边数为 n(n-1)/2（无向）、n(n-1)（有向、有向自环除外）。
    - 解题技巧：在完全图上很多 TSP / 最短路变体最坏情况复杂度很高，注意复杂度估算。
14. **稠密图 / 稀疏图 (Dense vs Sparse)**：稠密图边数接近 O(V^2)，稀疏图边数接近 O(V) 或 O(V log V) 等。
    - 解题技巧：选择表示（邻接矩阵适合稠密图，邻接表适合稀疏图），并据此选算法实现以免 TLE 或超内存。
15. **有向图（重复项）**：与第1项重复，提醒：有向图常出现拓扑排序、强连通分量、费用流等专用算法题。

---

### 常用图的表示与复杂度
- **邻接表 (Adjacency list)**：对每个顶点保存邻居列表，空间 O(V+E)，遍历所有边 O(V+E)。适合稀疏图和大多数算法（BFS/DFS/Prim/Kruskal 预处理）。
- **邻接矩阵 (Adjacency matrix)**：V×V 布尔/权值矩阵，空间 O(V^2)，查询边存在 O(1)。适合稠密图或需要常数时间判断两点是否相邻的场景。
- **边表 (Edge list)**：保存所有边（u,v,w），适合 Kruskal（需要对边排序）或离线处理。
- **其他**：关联矩阵/入度数组/出度数组等，按题目需要灵活选择。

---

### 常见题型与解题套路（实用技巧）
- **连通性 / 分量**：用 BFS/DFS 标记访问并统计分量数量；判断桥与割点可用 Tarjan（低链/dfn）。
- **最短路类**：
  - 无权最短路：BFS。
  - 非负权：Dijkstra（用优先队列，注意用 long long 和防止重复松弛造成的多余入队）。
  - 存在负边：Bellman-Ford（检测负环）；若想高效可尝试 SPFA，但注意最坏情况退化与题目数据特性。
  - 多源/多点：可用多源 BFS（把所有起点同时入队）或反向图跑单源。
- **最小生成树（MST）**：Kruskal（按边权排序 + 并查集）通常代码简洁，Prim（优先队列）适合邻接表。
- **强连通 / 拓扑**：Kosaraju/Tarjan 求 SCC；拓扑排序检测有向无环图（DAG），常用于任务调度类题。
- **欧拉路/欧拉回路**：无向图：0 或 2 个奇度顶点存在欧拉路；有向图：每个顶点入度=出度（回路），或某些差值规则（路）满足特定条件，同时图需弱连通或强连通的变种。
- **建模技巧**：把题目抽象成图（点代表状态/位置，边代表可行动作/转换），注意权重、方向与多边情况是否需要合并或拆分节点。

---

### 常见易错点
- **表示选错**：在稀疏图使用邻接矩阵导致 TLE 或内存爆炸；或在需要 O(1) 边查询但误用邻接表导致复杂度上升。
- **访问标记遗漏**：DFS/BFS 未及时标记 visited 导致死循环或重复计数。
- **方向混淆**：把有向边当无向处理（或反之），导致拓扑/连通性判断错误。
- **未处理多重边/自环**：在计度数、判断欧拉路或构造 MST 时漏掉这些情况会出错。
- **松弛/优先队列误用**：Dijkstra 中未检查已松弛的旧条目会导致额外开销（但不影响正确性），注意使用 distance 校验。
- **忽视边权符号**：用 Dijkstra 处理负权边会得错结果。

---

### 图的存储及基本操作
#### 邻接矩阵法
- **定义**：使用一个 V×V 的二维数组（矩阵）来表示图，其中 V 是顶点数。矩阵元素 adj[i][j] 表示顶点 i 到顶点 j 的边信息。对于无权图，通常用 0/1 表示有无边；对于带权图，用权值表示（不存在时用 INF 或 -1）。
- **空间复杂度**：O(V^2)，适合小规模图（V ≤ 1000），但对稀疏图浪费空间。
- **时间复杂度**：
  - 判断两顶点是否相邻：O(1)。
  - 枚举某一顶点的所有邻居：O(V)。
  - 添加/删除边：O(1)。
- **优点**：查询边存在快，适合稠密图或需要频繁判断相邻关系的场景。
- **缺点**：空间占用大，不适合稀疏图；枚举邻居时需遍历整个行，效率低。
- **实现要点**：初始化时将矩阵设为 0 或 INF；对于无向图，adj[i][j] = adj[j][i]；对于有向图，只设置单向。
- **解题技巧**：当 V 小且需要 O(1) 判断边时用邻接矩阵；常用于 Floyd 最短路算法，因为矩阵乘法方便。

#### 邻接表法
- **定义**：为每个顶点维护一个邻居列表，通常用向量或链表存储。每个元素表示一条边（邻居顶点和可选权值）。
- **空间复杂度**：O(V + E)，非常节省空间，适合稀疏图。
- **时间复杂度**：
  - 判断两顶点是否相邻：O(deg(u))，平均 O(1) 若用哈希集合。
  - 枚举某一顶点的所有邻居：O(deg(u))。
  - 添加/删除边：O(1)（尾插），但删除需查找 O(deg(u))。
- **优点**：空间高效，枚举邻居快，适合大多数图算法。
- **缺点**：查询特定边存在稍慢；若需快速判断相邻，可用 unordered_set 优化。
- **实现要点**：用 `vector<vector<pair<int,int>>> adj(V);` 对于带权图，`pair<int,int>` 表示 (邻居, 权值)；无权图可用 `vector<vector<int>>`。
- **解题技巧**：默认选择邻接表；遍历时注意避免重复访问边（无向图中每条边出现两次）；常用于 BFS/DFS/Dijkstra。

#### 十字链表法
- **定义**：一种链式存储结构，专门为有向图设计。每个顶点有出边链表和入边链表，每条弧（边）同时在出边链和入边链中出现，便于快速遍历入度和出度。
- **结构**：顶点节点包含 firstOut（出边链头）和 firstIn（入边链头）；弧节点包含 tail（起点）、head（终点）、nextOut（出边链下一个）、nextIn（入边链下一个）。
- **空间复杂度**：O(V + E)。
- **时间复杂度**：枚举出边 O(outdeg(u))，枚举入边 O(indeg(u))。
- **优点**：便于处理有向图的入出边操作，适合网络流或需要频繁访问反向边的场景。
- **缺点**：实现复杂，空间稍多于邻接表。
- **解题技巧**：当题目强调有向图且需高效处理入边时考虑；常用于最大流算法中的残余图。

#### 临界多重表
- **定义**：用于处理多重边或需要边属性的图。类似于邻接表，但边是独立节点，顶点指向其关联的边链。
- **结构**：边节点包含两个顶点、权值、多重边标记；顶点节点指向其关联边链。
- **空间复杂度**：O(V + E)，但边数可能因多重而增加。
- **时间复杂度**：枚举顶点关联边 O(deg(u))。
- **优点**：支持多重边和边删除操作，适合动态图。
- **缺点**：实现更复杂，空间稍大。
- **解题技巧**：当图有大量多重边或需频繁删除边时用；如在某些图论问题中处理边权重更新。

#### 基本操作
- **添加边 (addEdge(u, v, w))**：邻接矩阵 O(1)，邻接表 O(1)（尾插）。
- **删除边 (removeEdge(u, v))**：邻接矩阵 O(1)，邻接表 O(deg(u))（需查找）。
- **查询边 (hasEdge(u, v))**：邻接矩阵 O(1)，邻接表 O(deg(u)) 或 O(1)（哈希）。
- **枚举邻居 (iterateNeighbors(u))**：邻接表 O(deg(u))，邻接矩阵 O(V)。
- **计算度数 (degree(u))**：邻接表 O(deg(u))，邻接矩阵 O(V)。
- **解题技巧**：封装成类或函数；初始化时注意清空；带权图用 long long 避免溢出；删除操作若频繁，用标记延迟删除。

### 图的遍历
#### 深度优先搜索（DFS）
- **定义**：从某个顶点出发，沿着一条路径尽可能深入，直到无法继续，再回溯到上一个分支点，继续探索其他路径。使用递归或栈实现。
- **递归实现模板**（邻接表）：
  ```cpp
  vector<bool> visited(V, false);
  void dfs(int u) {
      visited[u] = true;
      cout << u << " ";  // 访问操作
      for (auto [v, w] : adj[u]) {
          if (!visited[v]) {
              dfs(v);
          }
      }
  }
  ```
- **栈实现（非递归）**：用栈模拟递归，避免栈溢出。
- **复杂度**：时间 O(V + E)，空间 O(V)（递归栈或显式栈）。
- **应用**：连通分量计数、拓扑排序（递归版）、检测环（有向图用颜色标记：白未访问、灰在栈中、黑已完成）、生成树。
- **易错点**：递归深度过大导致栈溢出（用非递归版）；无向图中需标记 visited 避免重复访问；有向图环检测需三色标记。

##### 深度优先的生成树和生成树林
- **生成树**：对连通图，DFS 从根出发构建的树，包含所有顶点，无环。
- **生成树林**：对不连通图，对每个未访问顶点运行 DFS，得到森林。
- **DFS 序列**：记录发现时间 (dfn) 和结束时间 (finish)，用于 Tarjan 算法求桥、割点、SCC。
- **性质**：DFS 生成树中，树边是发现边，回边是已访问边。
- **解题技巧**：在 DFS 中记录父节点，避免误判回边；用于求连通分量或最小生成树（但不如 Kruskal/Prim 高效）。

#### 广度优先搜索（BFS）
- **定义**：从某个顶点出发，按层次扩展，先访问所有邻居，再访问邻居的邻居。使用队列实现。
- **模板**（无权单源最短路）：
  ```cpp
  vector<int> dist(V, -1);
  queue<int> q;
  q.push(s);
  dist[s] = 0;
  while (!q.empty()) {
      int u = q.front(); q.pop();
      for (auto [v, w] : adj[u]) {
          if (dist[v] == -1) {
              dist[v] = dist[u] + 1;
              q.push(v);
          }
      }
  }
  ```
- **复杂度**：时间 O(V + E)，空间 O(V)。
- **应用**：无权最短路、二分图判定（染色）、层次遍历、连通分量（多源 BFS）。
- **易错点**：忘记标记 visited，导致重复入队；队列中可能有旧距离，需检查 dist[v] == -1。

##### BFS 求单源最短路径 / Dijkstra 算法
- **BFS 单源最短路**：适用于无权图，dist[v] 为边数。
- **Dijkstra 算法**：适用于非负权图，使用优先队列进行贪心松弛。
  - **模板**：
    ```cpp
    vector<long long> dist(V, LLONG_MAX/2);
    dist[s] = 0;
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<void>> pq;
    pq.emplace(0, s);
    while (!pq.empty()) {
        auto [cost, u] = pq.top(); pq.pop();
        if (cost > dist[u]) continue;  // 旧条目
        for (auto [v, w] : adj[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.emplace(dist[v], v);
            }
        }
    }
    ```
  - **复杂度**：O((V + E) log V)（二进制堆）。
  - **解题技巧**：用 long long 防溢出；检查 cost > dist[u] 跳过旧条目；若边权 0/1，用 0-1 BFS（双端队列）优化到 O(V + E)。

##### 广度优先生成树
- **定义**：BFS 从根出发构建的树，边按层次添加。
- **性质**：树中路径为最短路（按边数）。
- **应用**：计算层次、近似 LCA（最低公共祖先）。
- **解题技巧**：记录父节点 parent[v] = u；用于无权图的最短路树。

#### 连通性
- **无向图连通性**：用 DFS/BFS 求连通分量数；若分量数为 1，则连通。
- **有向图连通性**：强连通分量 (SCC) 用 Kosaraju 或 Tarjan；弱连通用忽略方向后 BFS。
- **桥与割点**：桥是删除后增加连通分量的边；割点是删除后增加连通分量的顶点。用 Tarjan（dfn, low）。
- **解题技巧**：Tarjan 中 low[u] = min(dfn[u], low[v] for v in children, dfn[w] for back edges)；桥：low[v] > dfn[u]；割点：根有 >=2 子树，或非根有子 v 满足 low[v] >= dfn[u]。

### 图的应用
#### 最小生成树
最小生成树定义：
- **定义**：在连通带权无向图中，选择一个边的子集，使得所有顶点连通且总权值最小。
- **性质**：
  - MST 唯一当边权互异。
  - MST 的边是图中某些最小割的跨边。
  - 任意两点间 MST 路径权值 <= 原图最短路。
  - 总权值等于所有顶点权值减去最大匹配（某些性质）。

##### Prim 算法
- **思路**：从一个顶点开始，逐步添加与当前集合相连的最小权边到集合中。
- **实现**：用优先队列维护候选边。
  ```cpp
  vector<long long> dist(V, LLONG_MAX/2);
  vector<bool> inMST(V, false);
  dist[0] = 0;
  priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<void>> pq;
  pq.emplace(0, 0);
  long long total = 0;
  while (!pq.empty()) {
      auto [cost, u] = pq.top(); pq.pop();
      if (inMST[u]) continue;
      inMST[u] = true;
      total += cost;
      for (auto [v, w] : adj[u]) {
          if (!inMST[v] && dist[v] > w) {
              dist[v] = w;
              pq.emplace(w, v);
          }
      }
  }
  ```
- **复杂度**：O(E log V)。
- **解题技巧**：适合稠密图；用 dist 数组避免重复入堆。

##### Kruskal 算法
- **思路**：将边按权排序，依次添加不形成环的边。
- **实现**：用并查集判断环。
  ```cpp
  struct Edge { int u, v, w; };
  vector<Edge> edges;
  sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b){ return a.w < b.w; });
  DSU dsu(V);
  long long total = 0;
  int cnt = 0;
  for (auto& e : edges) {
      if (dsu.unite(e.u, e.v)) {
          total += e.w;
          cnt++;
          if (cnt == V-1) break;
      }
  }
  ```
- **复杂度**：O(E log E)（排序）。
- **解题技巧**：适合稀疏图；处理多重边时保留最小权。

#### 最短路径
##### Dijkstra算法
- **详见 BFS 小节**：非负权单源最短路。

##### Floyd 算法
- **定义**：多源最短路算法，使用动态规划，计算所有点对间最短路。
- **模板**：
  ```cpp
  vector<vector<long long>> dist(V, vector<long long>(V, LLONG_MAX/2));
  for (int i = 0; i < V; i++) dist[i][i] = 0;
  // 初始化 dist
  for (int k = 0; k < V; k++)
      for (int i = 0; i < V; i++)
          for (int j = 0; j < V; j++)
              if (dist[i][k] + dist[k][j] < dist[i][j])
                  dist[i][j] = dist[i][k] + dist[k][j];
  ```
- **复杂度**：O(V^3)。
- **应用**：传递闭包（用布尔矩阵）、检测负环（若 dist[i][i] < 0）。
- **解题技巧**：V 小时用；注意初始化和负权处理（Floyd 可处理负权但不检测负环）。

### 有向无环图描述表达式（DAG）
- **定义**：有向图中无环，顶点表示任务，边表示依赖。
- **应用**：任务调度、表达式解析、编译优化。
- **性质**：有拓扑序，可用 DP 求最长/最短路径。

### 拓扑排序
#### 基本概念
- **定义**：对 DAG 的顶点排序，使得每条边 u->v 中 u 在 v 之前。
- **存在性**：DAG 存在拓扑序；有环则不存在。
- **应用**：任务调度、依赖解析。

#### Kahn算法
- **思路**：用入度数组，入度 0 的顶点入队，依次弹出并减邻居入度。
- **模板**：
  ```cpp
  vector<int> indeg(V, 0);
  // 计算 indeg
  queue<int> q;
  for (int i = 0; i < V; i++) if (indeg[i] == 0) q.push(i);
  vector<int> order;
  while (!q.empty()) {
      int u = q.front(); q.pop();
      order.push_back(u);
      for (auto [v, w] : adj[u]) {
          if (--indeg[v] == 0) q.push(v);
      }
  }
  if (order.size() < V) // 有环
  ```
- **复杂度**：O(V + E)。
- **解题技巧**：检测环；可用于关键路径。

### 关键路径
#### 基本概念
- **定义**：在 DAG 中，关键路径是总工期最长的路径，决定项目完成时间。
- **相关概念**：最早开始时间 (ES)、最晚开始时间 (LS)、松弛时间 (slack)。

#### 关键路径算法
- **步骤**：
  1. 拓扑排序计算 ES[u] = max(ES[pred] + w(pred,u))。
  2. 逆拓扑计算 LS[u] = min(LS[succ] - w(u,succ))。
  3. slack[u] = LS[u] - ES[u]，slack=0 的活动在关键路径。
- **复杂度**：O(V + E)。
- **解题技巧**：加虚拟源汇；用于项目管理。

## 查找

### 1. 基本概念
* **静态查找**：在查找过程中不修改查找表（仅进行检索）。适用于数据不变的场景，如字典查询。
* **动态查找**：在查找过程中动态地插入或删除记录。适用于数据频繁更新的场景，如数据库索引。
* **查找表**：存储关键字和对应信息的集合，支持查找、插入、删除操作。
* **关键字**：用于标识记录的唯一值。
* **平均查找长度 (ASL)**：衡量查找效率的指标，查找成功/失败时的平均比较次数。

### 2. 线性结构
* **顺序查找**：从表的一端开始逐个进行记录的关键字和给定值的比较。
  - **算法步骤**：遍历数组，逐一比较关键字。
  - **时间复杂度**：O(n)，最坏情况查找最后一个元素。
  - **空间复杂度**：O(1)。
  - **适用场景**：小规模数据或无序数据。
  - **代码模板**：
    ```cpp
    int sequentialSearch(vector<int>& arr, int key) {
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] == key) return i;
        }
        return -1;
    }
    ```
  - **易错点**：忘记处理未找到的情况。

* **折半查找**：要求查找表是有序的顺序存储结构，通过不断折半缩小查找范围。
  - **算法步骤**：设置 low=0, high=n-1，计算 mid=(low+high)/2，比较 arr[mid] 与 key，若相等返回，否则调整 low/high。
  - **时间复杂度**：O(log n)。
  - **空间复杂度**：O(1)。
  - **适用场景**：有序数组查找。
  - **代码模板**：
    ```cpp
    int binarySearch(vector<int>& arr, int key) {
        int low = 0, high = arr.size() - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == key) return mid;
            else if (arr[mid] < key) low = mid + 1;
            else high = mid - 1;
        }
        return -1;
    }
    ```
  - **易错点**：mid 计算防止溢出；递归版需注意栈深度。

* **分块查找**：又称索引顺序查找，将表分成若干块，块间有序，块内无序。
  - **算法步骤**：先在索引表中折半查找块，再在块内顺序查找。
  - **时间复杂度**：O(log m + s)，m 为块数，s 为块大小。
  - **空间复杂度**：O(m)。
  - **适用场景**：数据量大，内存有限。
  - **易错点**：索引表维护块的最大值。

### 3. 树形结构
* **二叉排序树（BST）**：左子树节点值小于根节点，右子树节点值大于根节点的二叉树。
  - **插入**：递归比较插入位置。
  - **查找**：递归比较。
  - **删除**：分三种情况（叶节点、单子树、双子树）。
  - **时间复杂度**：平均 O(log n)，最坏 O(n)（退化链表）。
  - **代码模板**（简化）：
    ```cpp
    struct BSTNode {
        int val;
        BSTNode* left, *right;
        BSTNode(int v) : val(v), left(nullptr), right(nullptr) {}
    };
    BSTNode* insert(BSTNode* root, int val) {
        if (!root) return new BSTNode(val);
        if (val < root->val) root->left = insert(root->left, val);
        else root->right = insert(root->right, val);
        return root;
    }
    ```
  - **易错点**：删除双子树时找后继。

* **二叉平衡树（AVL 树）**：任意节点的左右子树高度差绝对值不超过 1 的二叉排序树。
  - **实现**：通过旋转保持平衡。
  - **旋转操作**：单旋转（左/右）、双旋转（左右/右左）。
  例如：
    - 右旋（LL 型）：
      ```cpp
      BSTNode* rightRotate(BSTNode* y) {
          BSTNode* x = y->left;
          BSTNode* T2 = x->right;
          x->right = y;
          y->left = T2;
          return x; // 新根
      }
      ```
  - **时间复杂度**：O(log n)。
  - **应用**：需要严格平衡的场景。


* **红黑树**：一种自平衡的二叉查找树，通过颜色属性确保树的平衡。
  - **性质**：根黑、叶黑、无连续红、黑高相等。
  - **操作**：插入/删除后调整颜色和旋转。
  - **时间复杂度**：O(log n)。
  - **应用**：STL map/set。

* **B 树、B+ 树**：多路平衡查找树，广泛应用于文件系统和数据库索引。
  - **B 树**：节点可有多个子树，平衡因子。
  - **B+ 树**：叶节点链成链表，便于范围查询。
  - **时间复杂度**：O(log n)。
  - **应用**：磁盘索引。

### 4. 散列结构——散列表
* **性能分析**：通常使用装填因子 α = n/m（n 元素数，m 槽数）来衡量散列表的平均查找长度。
  - ASL ≈ 1 + α/2（拉链法）。
* **冲突处理**：
    * **开放定址法**（如线性探测、平方探测等）。
      - **线性探测**：冲突时顺序查找下一个空槽。
      - **平方探测**：步长为 i^2。
      - **优点**：空间利用率高。
      - **缺点**：聚集现象。
    * **拉链法**（又称链地址法）。
      - **优点**：处理冲突简单，无聚集。
      - **缺点**：指针开销。
* **哈希函数**：如除留余数法、乘法散列。
* **代码模板**（拉链法）：
  ```cpp
  vector<vector<int>> hashTable(m);
  int hashFunc(int key) { return key % m; }
  void insert(int key) { hashTable[hashFunc(key)].push_back(key); }
  bool search(int key) {
      auto& bucket = hashTable[hashFunc(key)];
      return find(bucket.begin(), bucket.end(), key) != bucket.end();
  }
  ```

### 5. 效率指标——平均查找长度 (ASL)
* **查找成功**：在表中找到目标元素时，关键字比较次数的平均值。
  - 计算：Σ (查找第 i 个元素的比较次数) / n
* **查找失败**：确定目标元素不在表中时，关键字比较次数的平均值。
  - 计算：对所有可能失败位置求平均。
* **影响因素**：查找表组织方式、数据分布。
-----------------




## 排序

### 1. 基本概念
* **稳定性**：排序后相同关键字的相对顺序不变。
* **衡量标准**：时、空复杂度、稳定性。
* **内部排序**：数据在内存中排序。
* **外部排序**：数据在磁盘上排序。例如归并排序适合大数据量。

### 2. 内部排序
* **插入排序**
    * **直接插入排序**
      - **思路**：将元素插入已排序序列。
      - **时间复杂度**：O(n^2)，最好 O(n)。
      - **空间复杂度**：O(1)。
    
      - **稳定性**：稳定。
      - **代码**：
        ```cpp
        // 直接插入排序（Insertion Sort）
        // 思路：将当前元素插入到其前面已经排序的子数组中，保持前半部分有序。
        // 特性：稳定、原地，最好 O(n)、最坏 O(n^2)、空间 O(1)。
        void insertionSort(vector<int>& arr) {
            int n = (int)arr.size();
            // 从第二个元素开始，将 arr[i] 插入到 [0..i-1] 的有序区间
            for (int i = 1; i < n; ++i) {
                int key = arr[i];        // 待插入的元素
                int j = i - 1;          // 指向已排序区间的末尾
                // 把比 key 大的元素向右移动一个位置
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j]; // 右移
                    --j;
                }
                // 插入 key 到正确位置（j+1）
                arr[j + 1] = key;
            }
        }
        ```
      - **易错点**：边界检查。

    * **折半插入排序**
      - **思路**：用二分查找插入位置。
      - **时间复杂度**：O(n^2)，但比较次数减少。
      - **稳定性**：稳定。

    * **希尔排序**
      - **思路**：分组插入排序，逐步缩小间隔。
      - **时间复杂度**：O(n^{1.3}) ~ O(n^2)。
      - **稳定性**：不稳定。
      - **代码**：
        ```cpp
        void shellSort(vector<int>& arr) {
            int n = arr.size();
            for (int gap = n / 2; gap > 0; gap /= 2) {
                for (int i = gap; i < n; i++) {
                    int temp = arr[i], j;
                    for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                        arr[j] = arr[j - gap];
                    }
                    arr[j] = temp;
                }
            }
        }
        ```

* **交换排序**
    * **冒泡排序**
      - **思路**：相邻元素比较交换。
      - **时间复杂度**：O(n^2)。
      - **稳定性**：稳定。
      - **代码**：
        ```cpp
        void bubbleSort(vector<int>& arr) {
            int n = arr.size();
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);
                }
            }
        }
        ```

    * **快速排序**
      - **思路**：选择枢轴，分治排序。
      - **时间复杂度**：平均 O(n log n)，最坏 O(n^2)。
      - **稳定性**：不稳定。
      - **代码**：
        ```cpp
        void quickSort(vector<int>& arr, int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }
        int partition(vector<int>& arr, int low, int high) {
            int pivot = arr[high], i = low - 1;
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    swap(arr[i], arr[j]);
                }
            }
            swap(arr[i + 1], arr[high]);
            return i + 1;
        }
        ```

* **选择排序**
    * **简单选择排序**
      - **思路**：每次选最小元素交换。
      - **时间复杂度**：O(n^2)。
      - **稳定性**：不稳定。

    * **堆排序**
      - **思路**：建大顶堆，依次取出最大元素。
      - **时间复杂度**：O(n log n)。
      - **稳定性**：不稳定。
      - **代码**：
        ```cpp
        void heapSort(vector<int>& arr) {
            int n = arr.size();
            for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
            for (int i = n - 1; i > 0; i--) {
                swap(arr[0], arr[i]);
                heapify(arr, i, 0);
            }
        }
        void heapify(vector<int>& arr, int n, int i) {
            int largest = i, l = 2 * i + 1, r = 2 * i + 2;
            if (l < n && arr[l] > arr[largest]) largest = l;
            if (r < n && arr[r] > arr[largest]) largest = r;
            if (largest != i) {
                swap(arr[i], arr[largest]);
                heapify(arr, n, largest);
            }
        }
        ```

* **归并排序**
  - **思路**：分治合并。
  - **时间复杂度**：O(n log n)。
  - **稳定性**：稳定。
  - **代码**：
    ```cpp
    void mergeSort(vector<int>& arr, int l, int r) {
        if (l < r) {
            int m = l + (r - l) / 2;
            mergeSort(arr, l, m);
            mergeSort(arr, m + 1, r);
            merge(arr, l, m, r);
        }
    }
    void merge(vector<int>& arr, int l, int m, int r) {
        vector<int> temp(r - l + 1);
        int i = l, j = m + 1, k = 0;
        while (i <= m && j <= r) {
            if (arr[i] <= arr[j]) temp[k++] = arr[i++];
            else temp[k++] = arr[j++];
        }
        while (i <= m) temp[k++] = arr[i++];
        while (j <= r) temp[k++] = arr[j++];
        for (int p = 0; p < k; p++) arr[l + p] = temp[p];
    }
    ```

* **基数排序**
  - **思路**：按位排序，从低位到高位。
  - **时间复杂度**：O(d(n + k))，d 位数，k 基数。
  - **稳定性**：稳定。
  - **适用**：整数排序。

### 3. 外部排序
* **多路归并排序**
  - **思路**：将数据分成块，内部排序后多路归并。
  - **时间复杂度**：O(n log n)。
  - **应用**：大数据排序。

### 排序算法总结表
| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 | 实现难度 | 核心原理 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **冒泡排序** | $O(n^2)$ | $O(n)$ | $O(n^2)$ | $O(1)$ | 稳定 | ★☆☆☆☆ | 相邻交换，大的后移 | 教学演示，小规模数据 |
| **插入排序** | $O(n^2)$ | $O(n)$ | $O(n^2)$ | $O(1)$ | 稳定 | ★☆☆☆☆ | 构建有序区，扫描插入 | 几乎有序的数据，小数组 |
| **选择排序** | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 | ★☆☆☆☆ | 选最小的，交换到前面 | 交换成本极高的环境 |
| **希尔排序** | $O(n^{1.3})$ | $O(n)$ | $O(n^2)$ | $O(1)$ | 不稳定 | ★★☆☆☆ | 缩小增量，分组插入 | 中等规模数据，空间受限 |
| **快速排序** | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ | 不稳定 | ★★★☆☆ | 分治法，基准位左右分拨 | **通用首选**，大多数场景 |
| **归并排序** | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | 稳定 | ★★★☆☆ | 分治法，递归合并有序子序列 | 链表排序，外部排序（超大数据） |
| **堆排序** | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | 不稳定 | ★★★★☆ | 利用大顶堆/小顶堆结构 | 选 Top K 大的数，空间受限 |
| **计数排序** | $O(n+k)$ | $O(n+k)$ | $O(n+k)$ | $O(k)$ | 稳定 | ★★☆☆☆ | 统计元素频率，直接映射 | 范围 $k$ 较小的整数排序 |
| **桶排序** | $O(n+k)$ | $O(n)$ | $O(n^2)$ | $O(n+k)$ | 稳定 | ★★★☆☆ | 分桶后单独排序 | 均匀分布的数据 |
| **基数排序** | $O(n \times k)$ | $O(n \times k)$ | $O(n \times k)$ | $O(n+k)$ | 稳定 | ★★★☆☆ | 按数位（个十百）多轮分桶 | 固定位数的数据（手机号、日期） |